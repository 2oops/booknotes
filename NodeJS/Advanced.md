# Advanced

1. `NodeJs`是`JS`在服务端的运行环境，构建在`V8`引擎之上，基于事件驱动、非阻塞I/O模型，审核I/O密集型的应用场景。在`Web`服务器方面，`Nginx`也是采用的事件驱动的模式，其采用C语言编写，主要用来做高性能的`Web`服务器，而不适合做业务。

2. 单核CPU系统可采用`单进程 +单线程`，而多核CPU系统上，可使用`多进程+单线程`的模式，开启多进程并不是为了解决高并发，而是为了解决单进程模式下CPU利用率不足的情况，充分利用多核CPU的性能。

3. `NodeJs`虽然是单线程模型，但是基于事件驱动和异步非阻塞模式，它仍适合高并发场景。`JS`是单线程，但作为宿主环境的`NodeJS`并非单线程的。`process` 全局对象，无需`require`。

4. `NodeJs`进程创建

   `NodeJs`提供了`child_process`内置模块，用于创建子进程。

   - `child_process.spawn()`：适用于返回大量数据，例如图像处理，二进制数据处理。
   - `child_process.exec()`：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。
   - `child_process.execFile()`：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为
   - `child_process.fork()`： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 `V8` 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置

5. 守护进程

   守护进程是指运行在后台不受终端的影响

#### I/O(2019-11-03)

1. 阻塞I/O和非阻塞I/O

   非阻塞I/O：这种模式下一个用户进程发起一个 I/O 操作之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时 CPU 时间片可以用来做一些其它事情。

2. 同步I/O与异步I/O

3. `OSI`七层模型和网际网协议族图

   ![img](https://www.nodejs.red/nodejs/img/IO_%E7%94%A8%E6%88%B7%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4_OSI.png)

4. 操作系统的I/O模型分为5种：阻塞I/O、非阻塞I/O、I/O复用、信号驱动I/O、异步I/O

5. I/O多路复用：这里的 I/O 通常指网络 I/O，多路指多个 Socket 链接，复用指操作系统进行运算调度的最小单位**线程**。整体意思也就是多个网络 I/O 复用一个或少量的线程来处理 Socket。

   I/O多路复用有多种实现模式：`select poll epoll kqueue`

   `Nginx`即是基于`epoll`来实现的高并发，链接很小的情况下使用`select`可满足，但是大流量、高并发情况下`epoll`还是首选模型。

#### 内存管理和`V8`垃圾回收机制(2019-11-05)

1. `NodeJs`和`java`是一样的，由虚拟机进行内存自动管理。它是一个基于`V8`引擎的`Javascript`运行环境，所以`V8`可以说就是`NodeJs`中使用的虚拟机。

2. 垃圾回收是指回收那些不再应用的对象，当一个对象无法从根节点访问到就会被作为垃圾回收的候选对象，无法从根节点指的是不会再被任何其他对象所引用。

3. `V8`内存限制，在` V8 `中限制 64 位的机器大约 `1.4GB`，32 位机器大约为 `0.7GB`，对于一些大内存的操作需谨慎否则超出 `V8` 内存限制将会造成进程退出。

4. **在` V8` 中也提供了两个参数仅在启动阶段调整内存限制大小**
   - --max-old-space-size=2048
   - --max-new-space-size=2048

   新生代和老生代：绝大多数的应用程序对象生命周期都很短，少数的会比较长，因此`V8`将堆分为新生代和老生代，前者对象很小大概为`1-8M`，垃圾回收也很快，而新生代空间垃圾回收过程中幸存下来的对象会被提升到老生代空间。

   新生代空间：垃圾回收频繁，故此处理方式要求很快，采用`Scavenge`算法，其为一种复制算法，新生代空间会被分为两个相等大小的`from-space`和`to-space`，

   老生代空间：Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法。

5. 内存泄漏

   是指程序中已动态分配的堆内存由于某种原因未释放或者无法被释放，造成内存系统的浪费，导致程序运行速度减慢或者崩溃等严重后果。

   1. 全局变量：未声明的变量或挂载在全局`global`下的变量不会自动回收，直到进程退出才会被释放，或者通过`delete`或重新赋值为`undefined/null`解除引用关系，才会被回收。

   2. 闭包：闭包若引用父级函数中的变量，若闭包得不到释放，父级变量也就得不到释放，从而导致内存泄漏。

   3. 慎用内存做缓存，因为缓存中存储的键越多，长期存活的对象也就越多，垃圾回收时会对这些对象做无用功。

   4. 应避免不必要的模块加载，故此建议模块引用时仅在头部初次加载后使用`const`缓存起来。

   5. 其他开发细节：`clearInterval`，`map filter`等都是对数组操作，每次操作之后都会新建一个新的数组，故能用`forEach`代替`map`就用`forEach`

   6. 内存检测工具：`heapdump`是一个`dumpV8`堆信息的工具，[node-heapdump](https://github.com/bnoordhuis/node-heapdump)，

      `NodeJs `性能平台（`NodeJs` Performance Platform）是面向中大型` NodeJs` 应用提供 性能监控、安全提醒、故障排查、性能优化等服务的整体性解决方案。[alinode](https://www.aliyun.com/product/nodejs)

      轻量级的 `NodeJs` 项目内核性能监控 + 分析工具，[Easy Monitor](https://github.com/hyj1991/easy-monitor)

#### 测试相关

1. `QPS`：Query per Second，每秒查询量，规定时间内所能处理流量的大小，`QPS`=并发量/平均响应时间

2. `TPS`：Transaction per Second，每秒事物处理量，可用来描述系统的性能。

3. 两者的区别：就比如说一次下单请求，访问一次创建订单的接口产生一次`TPS`，但是随之会产生如查询地址，商品数据信息，商品价格，这些就会计入`QPS`，即产生了3次`QPS`。

4. 系统扩容评估：即二八法则，20%的时间承载80%的流量，这20%的时间称为峰值时间。

   假设一天有1000万`pv`，那需要的`QPS`即为：`1000000 * 0.8/(24 * 60 * 60 *0.2) = 463(QPS)`

   假设每台机器支撑`100QPS`，则大概需要5台机器。

5. 单元测试（`Unit`），端到端（`E2E`），行为驱动开发测试（`BDD`），ab压力测试（`Apachebench`的缩写，原理是创建多个并发线程，来模拟用户对同一URL地址请求从而进行的压力测试）。

